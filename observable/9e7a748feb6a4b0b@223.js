function _1(md){return(
md`# Klima DAO 2.0

dark_sole  
ds@darksole.vip

With contributions from scott@klimadao.finance

January 30, 2025

Autonomous Asset Manager, Liquidity and Bond Markets powered by a Dual Token structure designed for efficient and rational decentralised liquidity in the carbon offset markets.

**Copyright Notice**

This document represents original work by dark_sole ds@darksole.vip. While contributions from others are gratefully acknowledged, all intellectual property rights remain with the author. The models, algorithms, processes, products, methodologies, and concepts described herein are licensed exclusively for commercial use by Klima DAO. No other party may implement, copy, modify, or derive works from these materials without explicit written permission from the author.

© 2025 dark_sole. All rights reserved.

## 1 Introduction

Klima DAO was conceived to create market infrastructure driving seamless liquidity for Carbon monetisation and Carbon retirement. It has been constructed using decentralised architecture with a token system 'KLIMA' for dynamic economic governance. Whilst it has been successful in brand and customer acquisition, as well as acquiring real Carbon assets, the current token model and processes are unwieldy and will not allow the product to scale to its potential given the opportunity.

Hence we present **Klima 2.0** as a fundamental capital, liquidity and execution layer for wholesale Carbon trading.

### 1.1 Client base
There are two end-users of the platform that create the supply and demand of Carbon assets.

1. **Sellers** wishing to capitalise liquid or __forward__ delivery classes of Carbon. Forward-delivery trades at various discounts as a function of class and time.

2. **Buyers** who wish to retire Carbon in order to obtain the offset credit.

### 1.2 Automated Asset Manager

Both clients are facilitated through the Automated Asset Manager (**AAM**), a smart contract based system that continuously acquires (tokenised) Carbon, as well as selling offset certificates from its liquid Carbon portfolio, using the native **capital token** as a medium of exchange.`
)}

function _2(md){return(
md`Figure 1: Automated Asset Manager (AAM) Transaction Flow`
)}

function _3(md){return(
md`![Automated Asset Manager (AAM) Transaction Flow]()`
)}

function _4(md){return(
md`### 1.3 Dual tokens

The Klima economy shall be powered by two tokens:

1. Capital or **Asset token** as detailed above that determines Carbon class capital allocation by the AAM and the general forward (discount) curve for Carbon assets. These tokens are used to buy and sell Carbon as in Figure 1.

2. A **Risk Governance** token that combines with the capital token to shape the risk profile of the underlying Carbon portfolio.

The new tokens are named \`KLIMA\` and \`KLIMAX\` respectively, noting that the original token name carries through to the Asset Token reflecting the original utility. For the purposes of the document we shall refer to these tokens as \`\`A\`\` and \`\`G\`\` where brevity is required.

### 1.4 Core Economic Pillars

In addition to the AAM, there are two other tenets of Klima 2.0 that enable the model to find equilibrium through continous dynamic feedback loops. Importantly these are generated solely from token balances in the smart contracts and there is no oversight nor a centralised discretionary actor.

1. **AAM**: The Automated Asset Manager swaps its own token \`\`A\`\` for Carbon \`\`C\`\` (in) or Carbon offset certificates \`\`C^∗\`\` (out) to build a portfolio of Carbon.

   - Both \`\`A\`\` and \`\`G\`\` are also used as 'Staking' tokens in the AAM whereby \`\`A\`\` determines the weighting of any given Carbon class, and \`\`G\`\` determines the rate of acquisition (disposal).

   - Forward-delivery Carbon (for a set of fixed dates out to 10 years) is transacted simultaneously with liquid Carbon.

2. **Bond Market**: \`\`A\`\` holders stake tokens until a set expiry to create floating yield bonds.

   - The collective temporal staking pattern produces a yield curve to reward bond-holders as well as price the forward curve for the AAM.

   - Only \`\`A\`\` tokens participate in the Bond Market which is responsible for pricing the cost of **illiquidity**.

3. **Liquidity Market**: Here the tokens are traded in 2 core liquidity pairs with various incentives available to Liquidity Provider token holders (**LPs**), including a **risky-yield** generated by the Bond Market.

   - \`\`\\overline{AG}\`\`: Native token swap \`\`A\`\` and \`\`G\`\`.

   - \`\`\\overline{AQ}\`\`: The asset token \`\`A\`\` with USDC \`\`Q\`\`.

   The Liquidity Market provides the complementary facility to the Bond Market and the critical relationship between the native tokens and the hard currency of USDC.`
)}

function _5(md){return(
md`Figure 2: Market Architectures, Token Utility`
)}

function _6(md){return(
md`The Klima 2.0 system enables each participant in the various economic pillars to act in the (selfish) interests of their own capital and utility, which through the harmonic model, enables price discovery, liquidity and stability for Carbon trading which feeds back on itself as a catalyst for growth and scale.

### 1.5 Initialisation of the \`KLIMA\` Asset Token:

Klima DAO has approximately 20 million tonnes of **Carbon** credits in its treasury as assets which will be used to create the initial issuance of \`\`A\`\` tokens upon launch of Klima 2.0.

### 1.6 User Experience

A summary of user functionality:

- AAM
   - Tokenise Carbon that is liquid or forward-delivery to create \`\`C\`\` tokens.
   - Swap Carbon \`\`C\`\` (liquid and forward) for \`\`A\`\` tokens.
   - Swap \`\`A\`\` tokens \`\`A\`\` for liquid Carbon offset certificate \`\`C^∗\`\`.
   - Stake \`\`A\`\` tokens for specific Carbon classes to contribute to the underlying portfolio weighting and pricing.
   - Stake \`\`G\`\` tokens for specific Carbon classes to contribute to the underlying portfolio pricing and capacity.

- Bond Market
   - Stake \`\`A\`\` tokens for set maturities to create Bonds and receive yield.

- Liquidity Market
   - Swap \`\`A\`\` tokens for \`\`G\`\` or USDC \`\`Q\`\` in the Liquidity Market.
   - Swap \`\`G\`\` tokens for \`\`A\`\` in the Liquidity Market.
   - Add \`\`A\`\` tokens, \`\`G\`\` tokens or USDC \`\`Q\`\` to liquidity pools and stake LP tokens to receive fees and a share of \`\`G\`\` incentives and \`\`A\`\` yield.

## 2 Economic System

The customer activity is managed through a smart contract asset manager driven by staking choices from the token system, the balances of assets held, and the discount curves generated by the bond market.`
)}

function _7(md){return(
md`Figure 3: Autonomous Asset Manager - Detailed Architecture`
)}

function _8(md){return(
md`The AAM is a smart contract exchange platform that facilitates:

1. The sale of Carbon in return for newly issued \`\`A\`\` tokens.

2. The issuance of retirement certificates to burn \`\`A\`\` tokens.

The combined staking of \`\`A\`\` and \`\`G\`\` Tokens creates a dynamic pricing matrix by class of Carbon, and by time, enabling spot and forward trading of Carbon.`
)}

function _9(md){return(
md`## 3 Two Token Model

The current token is deprecated and replaced with two new tokens:`
)}

function _10(md){return(
md`Figure 4: Token Derivation Structure`
)}

function _11(md){return(
md`\`\`A\`\` is issued autonomously to acquire Carbon and is a tokenised representation of the underlying Klima Carbon portfolio. It is also minted to pay Bond yields and Risky Yield for LPs, and is burnt when Carbon certificates are purchased.

The \`\`A\`\` token has __2 independent__ staking functions:`
)}

function _12(md){return(
md`Figure 5: Asset Token Staking Dimensions`
)}

function _13(md){return(
md`1. **Price**: Collective selection of Carbon classes by \`\`A\`\` staking determines the instantaneous price ratio for \`\`A\`\` token issuance. This stake can be amended and withdrawn at any time to allow price modulation for the platform of its Carbon assets.

2. **Time**: The \`\`A\`\` token is locked for a specific period of time representing a liquidity preference for the holder in return for yield. This part of the stake cannot be amended.

The \`\`G\`\` token has a __single__ staking function that also selects Carbon classes. This determines the rate of issuance or price curve of \`\`A\`\` for the specified Carbon, as well as the retirement burning rate.

Both tokens facilitate the Klima Carbon market to function efficiently with the \`\`A\`\` token responsible for portfolio selection and pricing, and the \`\`G\`\` token modulating capacity and risk.`
)}

function _14(md){return(
md`Table 1: Token Summary

| Token                | Amount      | Notes                                                            |
|:-------------------- |:----------- |:---------------------------------------------------------------- |
| \`KLIMA\` \`\`A\`\` Token  | 20 million  | Supply expands and contracts perpetually.                        |
|                      |             | 87.5% of initial supply available to existing KLIMA holders.     |
|                      |             | Initially created on 1:1 basis with Carbon Tonnes held.          |
|                      |             | Issues on Carbon received, and Burns on Carbon retired.          |
|                      |             | _Sets portfolio weights for Carbon classes_                      |
|                      |             | _Sets discount curve for foward pricing_                         |
| \`KLIMAX\` \`\`G\`\` Token | 100 million | Fixed supply                                                     |
|                      |             | 40% put into programmatic issuance as incentive yield over time. |
|                      |             | 40% for existing KLIMA holders                                   |
|                      |             | _Sets capacity-price curve for Carbon classes_                   |
|                      |             | _Sets retirement spread for Carbon offsets_                      |`
)}

function _15(md){return(
md`## 4 Bond Market

Holders of \`\`A\`\` can stake (select) a bond maturity from the set of **standard maturities**. Bonds expire every 90 days on a rolling basis. There are always 40 maturities extending out to approximately 10 years for bond staking.

- Collective Bond staking detemines the shape of the discount curve of the \`\`A\`\` token with regards to its purchasing rate of forward Carbon

- Bondholders receive a floating yield of new \`\`A\`\` tokens on their stake following the shape of this discount curve. Yield is calculated daily and accumulates to the principal stake.

- There is no un-staking and all principal and accumulated yield is released at bond maturity.

\`\`G\`\` Tokens are not involved in the bond market and the forward curve is agnostic to Carbon class (as Carbon selection for portfolio weighting is an independent utility function of \`\`A\`\`).

### 4.1 Bond Market Calculations

Defining:

- \`\`S\`\`: Total \`\`A\`\` tokens staked for Bonds expressed as a proportion of outstanding supply of \`\`A\`\`.

- \`\`S_t\`\`: Total \`\`A\`\` tokens staked for each Bond maturity bucket \`\`t\`\`, expressed as a proportion of outstanding supply of \`\`A\`\`, where \`\`\\sum S_t = S\`\`, and \`\`t\`\` is the index of standard maturities \`\`t \\in \\{ 1, 2, \\dots, 40 \\}.\`\`

- \`\`E_t\`\`: Time to expiry expressed in years.`
)}

function _data(FileAttachment){return(
FileAttachment("penguins.csv").csv({typed: true})
)}

function _17(tex){return(
tex.block`c = \pm\sqrt{a^2 + b^2} \tag{1}`
)}

function _S_input(Inputs,tex){return(
Inputs.range([0, 1], {label: tex`S`, step: 0.1})
)}

function _D_input(Inputs,tex){return(
Inputs.range([-1, 1], {label: tex`D`, step: 0.1})
)}

function _C_input(Inputs,tex){return(
Inputs.range([-1, 1], {label: tex`C`, step: 0.1})
)}

function _21(Plot,S){return(
Plot.line(S).plot()
)}

function _linear(){return(
function linear(E, S, D_input, C_input) {
    if (E.length === 1) {
        return [S];
    }

    let t1 = 0;
    let t2 = E.length - 1;
    let slope = 0.002 * Math.atanh(D_input);
    let intercept = S / E.length;

    if (Math.abs(slope) > 2 * intercept / (t2 - t1 - 1)) {
        let t_shift = Math.max(1, Math.round(Math.sqrt(Math.abs(2 * S / slope))));
        if (slope > 0) {
            t1 = t2 - t_shift;
        } else {
            t2 = t1 + t_shift;
        }
        slope = Math.sign(slope) * 2 * S / Math.pow((t2 - t1), 2);
        intercept = Math.abs(slope) * (t2 - t1 - 1) / 2;
    }

    let S_vec = [];
    for (let i = 0; i < E.length; i++) {
        let t = i - (t1 + t2) / 2;
        S_vec.push([E[i], Math.max(0, slope * t + intercept)]);
    }

    return S_vec;
}
)}

function _linearRange(){return(
function linearRange(start, stop, step) {
    let range = [];
    for (let i = start; i <= stop; i += step) {
        range.push(i);
    }
    return range;
}
)}

function _dotProduct(){return(
function dotProduct(A, B) {
    if (A.length !== B.length) {
        throw new Error("Vectors must have the same length");
    }
    let product = 0;
    for (let i = 0; i < A.length; i++) {
        product += A[i] * B[i];
    }
    return product;
}
)}

function _weightedArithmeticMean(dotProduct){return(
function weightedArithmeticMean(vector, weights) {
    let dotProd = dotProduct(vector, weights);
    let sum = weights.reduce((acc, val) => acc + val, 0);
    let mean = dotProd / sum;
    return mean;
}
)}

function _computeGamma(){return(
function computeGamma(E, D, C) {
    let E_div_D = E.map(e => e / D);
    let E_squared = E.map(e => e * e);
    let two_C = 2 * C;
    let gamma = E_div_D.map((value, index) => {
        return Math.max(0, value - E_squared[index] / two_C);
    });
    return gamma;
}
)}

function _normalize(){return(
function normalize(vector) {
    let sum = vector.reduce((acc, val) => acc + val, 0);
    let normalized = vector.map(val => val / sum);
    return normalized;
}
)}

function _computeCumsum(){return(
function computeCumsum(vector) {
    let cumsum = [];
    let sum = 0;
    for (let i = 0; i < vector.length; i++) {
        sum += vector[i];
        cumsum.push(sum);
    }
    return cumsum;
}
)}

function _computeZ(){return(
function computeZ(S, Gamma, E) {
    return S.map((s, index) => {
        return (1 - s) * Gamma[index] / E[index];
    });
}
)}

function _computeB(){return(
function computeB(Z, E) {
    let B = Z.map((z, index) => Math.exp(-z * E[index]));
    return B;
}
)}

function _E(linearRange){return(
linearRange(0.25, 10, 0.25)
)}

function _S(linear,E,S_input,D_input,C_input){return(
linear(E, S_input, D_input, C_input)
)}

function _x(){return(
[1, 2, 3, 4, 5]
)}

function _y(){return(
[2, 4, 6, 8, 10]
)}

function _35(aapl){return(
aapl
)}

function _36(Plot,S){return(
Plot.line(S).plot()
)}

function _37(S){return(
S
)}

function _38(Plot,data){return(
Plot.plot({
  marks: [
    Plot.rectY(data, { bin: "extent", thresholds: 5, fill: "steelblue" }) // Create a binned plot
  ],
  x: { grid: true },  // Add grid lines to the x-axis
  y: { grid: true },  // Add grid lines to the y-axis
  xLabel: "Frequency", // Label for the x-axis
  yLabel: "Value",    // Label for the y-axis
})
)}

function _39(Plot,data){return(
Plot.plot({
  y: {grid: true},
  color: {legend: true},
  marks: [
    Plot.rectY(data, Plot.binX({y: "count"}, {x: "flipper_length_mm", fill: "sex"})),
    Plot.ruleY([0])
  ]
})
)}

export default function define(runtime, observer) {
  const main = runtime.module();
  function toString() { return this.url; }
  const fileAttachments = new Map([
    ["penguins.csv", {url: new URL("./files/715db1223e067f00500780077febc6cebbdd90c151d3d78317c802732252052ab0e367039872ab9c77d6ef99e5f55a0724b35ddc898a1c99cb14c31a379af80a.csv", import.meta.url), mimeType: "text/csv", toString}]
  ]);
  main.builtin("FileAttachment", runtime.fileAttachments(name => fileAttachments.get(name)));
  main.variable(observer()).define(["md"], _1);
  main.variable(observer()).define(["md"], _2);
  main.variable(observer()).define(["md"], _3);
  main.variable(observer()).define(["md"], _4);
  main.variable(observer()).define(["md"], _5);
  main.variable(observer()).define(["md"], _6);
  main.variable(observer()).define(["md"], _7);
  main.variable(observer()).define(["md"], _8);
  main.variable(observer()).define(["md"], _9);
  main.variable(observer()).define(["md"], _10);
  main.variable(observer()).define(["md"], _11);
  main.variable(observer()).define(["md"], _12);
  main.variable(observer()).define(["md"], _13);
  main.variable(observer()).define(["md"], _14);
  main.variable(observer()).define(["md"], _15);
  main.variable(observer("data")).define("data", ["FileAttachment"], _data);
  main.variable(observer()).define(["tex"], _17);
  main.variable(observer("viewof S_input")).define("viewof S_input", ["Inputs","tex"], _S_input);
  main.variable(observer("S_input")).define("S_input", ["Generators", "viewof S_input"], (G, _) => G.input(_));
  main.variable(observer("viewof D_input")).define("viewof D_input", ["Inputs","tex"], _D_input);
  main.variable(observer("D_input")).define("D_input", ["Generators", "viewof D_input"], (G, _) => G.input(_));
  main.variable(observer("viewof C_input")).define("viewof C_input", ["Inputs","tex"], _C_input);
  main.variable(observer("C_input")).define("C_input", ["Generators", "viewof C_input"], (G, _) => G.input(_));
  main.variable(observer()).define(["Plot","S"], _21);
  main.variable(observer("linear")).define("linear", _linear);
  main.variable(observer("linearRange")).define("linearRange", _linearRange);
  main.variable(observer("dotProduct")).define("dotProduct", _dotProduct);
  main.variable(observer("weightedArithmeticMean")).define("weightedArithmeticMean", ["dotProduct"], _weightedArithmeticMean);
  main.variable(observer("computeGamma")).define("computeGamma", _computeGamma);
  main.variable(observer("normalize")).define("normalize", _normalize);
  main.variable(observer("computeCumsum")).define("computeCumsum", _computeCumsum);
  main.variable(observer("computeZ")).define("computeZ", _computeZ);
  main.variable(observer("computeB")).define("computeB", _computeB);
  main.variable(observer("E")).define("E", ["linearRange"], _E);
  main.variable(observer("S")).define("S", ["linear","E","S_input","D_input","C_input"], _S);
  main.variable(observer("x")).define("x", _x);
  main.variable(observer("y")).define("y", _y);
  main.variable(observer()).define(["aapl"], _35);
  main.variable(observer()).define(["Plot","S"], _36);
  main.variable(observer()).define(["S"], _37);
  main.variable(observer()).define(["Plot","data"], _38);
  main.variable(observer()).define(["Plot","data"], _39);
  return main;
}
